	\section{术语、符号和约定}
	我们称一个在输入上在最坏情况下以多项式时间终止的程序为随机多项式时间程序。让我们用{M}表示随机多项式时间程序的标准枚举。用{Nj}表示多项式时间非确定性程序的标准枚举；因此，每个NP集合至少由我们枚举中的一个程序识别。我们用L(Nj)表示由XI识别的集合（或语言）。
	
	设N是一个非确定性多项式时间程序，S(N)。我们称N在输入x上的每个接受路径为实例z在S中的一个证据。在没有性的情况下，对于任何固定的程序N，实例的长度n决定了证据的长度m，并且函数n H n + m是单射。我们用w，”表示z E S的证据集合。
	
	我们用PF表示多项式时间可计算函数的类；函数f E PF的值域不必是{O,l}，因此PF是计算字符串在P中的集合成员资格的函数的类的一个真超集。
	
	我们用S,表示长度为n的S的元素。符号A表示程序的默认输出；它可以用来表示所需的输出不存在，或者程序未能找到它。
	
	我们考虑的所有生成程序都作为输入长度n（用一元表示法表示），在多项式时间内运行，并产生S,的元素；因此，根据定义，我们关注的是高效的生成。
	
	\section{不可攻破的生成器}
	在本节中，我们提供一个理论框架，以考虑生成困难、已解决实例的问题。我们精确地定义了“对多项式时间对手安全的实例-证据对分布”的含义。我们的第一个定理解决了NP中哪些集合具有不可攻破的生成器的问题，如果确实存在的话。标题：生成方案的不可侵犯性
	
	
	
	某些集合具有这样的特性。定理2探讨了这些生成方案究竟有多安全。最后，定3探讨了需要哪些复杂性理论假设才能证明不可侵犯生成方案的存在。
	
	定义：我们用Gi,j表示（i，j）代生成方案，它是一个程序，在输入I"时，首先模拟M；在输入1"并得到一个输出字符串y。如果y的形式为（z，w），其中121=n且w是在输入z时N的接受计算，那么Gi,j输出（I，w；否则，它输出A。
	
	考虑以下游戏，由生成方案Gi,j和PF中的对手f进行。游戏的输入是一个字符串1;第一步是Gi,j在输入1上的运行。如果Gij输出一个对（z，w}，那么第二步是f输出f(z)；如果Gj,j输出A，那么在第一步之后游戏结束。函数f在游戏中获得胜利，如果生成方案输出A，或者生成方案输出（5，w）且f(z)是Nj在输入I上的接受计算w，否则生成方案获胜。注意w不必须等于w；例如，在第1节的识别方案中，对手f可以破坏用户A的安全性，如果他计算出A的公式的任何满足解-他不需要发现A在密钥分发期间被赋予的私有解。

定义：如果对于所有f∈PF，存在无穷多个长度n，使得f在输入1"上获胜的概率最多为1-a，其中a是[0,1]中的常数，那么生成方案是a-不可侵犯的。这个概率是在输入1"上的游戏运行中计算的。

定义：如果存在一对（i，j），使得Gi,j是a-不可侵犯的且S=L(Nj)，那么NP中的集合S是a-不可侵犯的，其中a是[0,1]中的常数。

请注意，不可侵犯的生成方案与密码学上安全的单向函数密切相关。

假设g是PF中的长度保持函数并且任何多项式时间程序在无穷多个长度上至少失败了一定比例的g的输出（其中“反向”意味着“找到一些原像元素”），那么g的像具有一个不可侵犯的生成方案：在输入I"时，生成一个长度为n的随机w，并令x等于g(w)。类似地，不可侵犯的生成方案Gi,j可以产生一个密码学上安全的单向函数。程序M;可以被看作是从硬币抛掷序列到对（z，w）的映射。令g是函数，它将硬币抛掷序列映射到M;输出的第一组件I。那么g必须对任何多项式时间对手在无穷上难以反向；如果不是这样，对手可以发现一个硬币抛掷序列，它产生了（I，w），那么方案Gi,j就是易受攻击的。303
如果要求在两种情况下，对手在足够高的长度上失败，而不是只在无穷多的长度上失败，那么相同的评论也适用。
我们不声称根据我们的定义不可侵犯的生成方案在实践中一定有用。例如，在[6]中的密钥分发者当然希望知道不仅仅是存在无穷多的长度，在这些长度上特定的多项式有界对手以高概率被挫败；他还希望知道这样的长度在实际大小上是可行的，并且有一个找到它们的程序。然而，我们定义的不可侵犯性的确提供了一个好的出发点，来进行一个复杂性理论上的研究。
定理1（完备性）：如果任何NP集合对某个正数a是不可侵犯的，那么SAT也是对a不可侵犯的。
证明（概要）：完整的分为三个阶段。首先，我们构造一个“通用生成方案”Gu，它模拟所有可能的生成方案，捕获它们中存在的常数比例的不可侵犯性。接下来，我们构造一个SAT的生成器，它将Cook的归约应用于Gu生成的集合Su，以保持不可侵犯性。最后，我们展示失去的不可侵犯性比例可以被重新捕获。
对于通用生成器Gu，我们需要一个程序Mu，其运行时间由特定的多项式限制，以模拟无穷多的程序，这些程序的单个运行时间可能是任意高阶多项式。我们通过以下引理克服这个障碍；它保证我们只需要考虑在程序M运行二次时间的生成器{Gk}。
引理：如果Gi,j是a不可侵犯的，那么存在一个a不可侵犯的生成方案Gi),jt，其中M;,运行在二次时间。
我们不能使用Cook证明SAT的NP完全性时所用的“通用减少”来构造一个通用生成器。这样的减少可能不一定是长度一致的（即，将相同长度的实例映射到相同长度的实例）。此外，即使我们的通用减少将长度为n的实例映射到长度为nk的实例，它也可能不保持不可侵犯性：非正式地说，如果特定生成器G，输出的“困难实例”代表长度n的概率质量的常数比例a，它们的映像不一定是长度nk的概率质量的常数比例，仅仅是因为nk的实例数量如此之多。
我们使用一个非标准的配对函数来克服这个困难。它将标题：将正整数分为“列”


将正整数按照以下方式分为“列”：列m，由所有形式为2m-1 + k 的整数组成，其中k ≥ 0。每个输入长度n恰好属于一个列——即索引比n的二进制表示中最不显著的“1”位大1的那个列。在输入I"时，GU \&st hds m，包含n的列的索引，然后从区间[n - 2,n)中均匀选择一个整数1。接下来，Gu模拟G，在输入1\ 上获得(z,~)，填充2，并输出(\)。

引理：如果G，是不可摧毁的，那么Gu是(a/2")-不可摧毁的。

简而言之，为了对于所有f在PF中，存在无穷多个长度n，使得f在Gu的输出上以至少a/2m的概率“”失败，我们证明任何这样的f都对应一个函数f ，它在无穷多个长度n 上以至少a的概率无法破解G，的输出。由于“困难长度”n （对于f 和G，）对应于“困难长度”n（对于f和Gu），使得n  E [n - 2", n); 因此Gu仅以概率2-"选择模拟G，在输入1"上运行。请注意，~~12~ 实际上是一个常数，因为m只是我们枚举中生成器的（固定的）索引。

为了构造一个(~/2")-不可摧毁的生成器G~AT用于SAT，我们利用了生成器GU中的Mu在立方时间内运行的事实。我们修改了Cook的归约，使得当应用于在立方时间内运行的NP机器时，它将长度为k的实例产生长度恰好为k4的实例。这种修改后的Cook归约T还诱导了一个从Su成员资格的证人映射到SAT元素满足赋值的映射。因此AT的行为如下：在输入In时，如果n不是完美的四次方，它输出A。否则，它模拟GU在输入Ik上的运行，其中k4 = n，获得一个对(z,w)，并输出r( (z, w))。我们将在全文中证明GSAT至少与Gu一样不可摧毁。

定理2，如下，保证如果SAT有一个(a/2m)-不可摧毁的生成器，那么它也有一个a-不可摧毁的生成器。

推论：在二次剩余假设、离散对数假设或因数分解假设下，存在一个a-不可摧毁的生成器用于SAT，对于某些a E (0,l)。

注释1：出于密码学目的，人们真的需要比这更多的东西吗？这里存在一个无穷集的“困难长度”对于密码学目的。请注意，定理1的证明提供了一些希望，因为如果某些G，在1和n之间的t(n)长度上击败了一个对手，那么Gu将在1和n之间的fl(t(n))长度上击败相应的对手。标题：305


如果使用一个标准的配对函数，该函数将两个参数都四倍拉伸，那么上述结论就不会成立。
定理2（放大）：如果一个NP集合S对于某个正数p是\&invulnerable的，那么对于所有a属于(0,1)，S也是a-invulnerable的。
证明（概要）：需要证明a-invulnerability意味着2a/(1+a)-invulnerability，因为由序列定义的极限a0 = a, ai = 2ai-1/(1+ai-1)的极限是1。
直观上，我们将展示如何以最自然的方式增加不脆弱性：生成实例，尝试破解它们，并丢弃破解的实例。假设Gi,j是一个a-invulnerable的生成器，并且S = L(Nj)。如果Gi,j是(a + (1 - a)/2)-invulnerable的，那么我们完成了，因为(a + (1 - a)/2) > (2a/(1 + a));否则，假设它不是。那么，根据定义，存在一些f E PF，它在所有除有限多个输入1"之外的情况下，以大于(1 - a)/2的概率赢得Gi,j。
考虑生成器Gi,j，它的工作方式如下：首先，它在输入1"上运行Mi，就像Gi,j一样。如果Mi输出(2, w},那么Gi,j计算f(z)并检查它是否是Nj在输入x上的接受计算。如果是，那么Gi,j再次在输入1"上运行Mi；否则，Gi,j输出(2, w}。如果f在足够多的连续游戏中获胜，那么i,j输出A。
显然，Gi,j生成的集合与Gi,j相同，即L(Nj)。在全文中，我们证明了Gej是(2a/(1 + a))-invulnerable的，并得出一个足够好的关于f和Gi,j之间游戏次数的界，使得Gi,j必须模拟。
注释2：为了简化，我们将对手建模为一个确定性的多项式时间函数。显然，在实践中，随机的多项式时间对手。定理1和2即使在我们定义invulnerability时量化所有随机的多项式时间函数的情况下也成立。我们在全文中给出详细信息。

在定理1中，是否可以减弱假设，即NP中至少有一个集合是a-invulnerable的？显然存在一些相对于这些oracle的invulnerable生成器。事实上，一个随机oracle就足够了([19])。在这些相对化的世界中，P # NP。P # NP的假设足以证明invulnerable生成器存在吗？我们接下来的定理表明，这样的证明不会相对化。
定理3（相对化）：存在一个oracle B，使得PB # NPB，并且相对于B，invulnerable生成器不存在。标题证明（概要）

证明（概要）：设B = QBFeK，其中@表示不相交并，K是一个极其稀疏的字符串集合，这些字符串具有最大的Kolmogorov复杂度。具体来说，K包含每个长度ni的字符串，其中序列nl, n2, ...以下定义：nl = 2，对于i > 1，ni是nl-1的三次指数；如果 ∈ K且1x1 = n，则z的Kolmorov复杂度为n。QBF的包含使得具有访问B的机器具有PSPACE的全部能力。

使用[13]中的技术证明PB # NPB是直接的。为了证明不存在相对于B的不可侵犯的生成器，设Gj,是一个能够访问到询问的生成方案，并假设它是对于某个常数a在(01)内a-不可侵犯的。我们通过构造一个在PFB中能够破解比1-cr更高比例的所有实例的对手f来得出矛盾。以下是f的描述以及它为何有效：

生成器Gj,涉及一个随机化多项式时间程序Mj和一个非确定性多项式时间程序Nj，两者都可以在任何步骤查询B。设nk1和nk2是对Mj和Nj运行时间的界限，且k是一个大于max(k1,k2)的整数当尝试破解长度为n的实例z时，f首先构造包含所有长度小于log(nck)的K元素的集合K ，其中c是一个适当选择的常数。由于K如此稀疏，最多只有一个字符串r在K \ K 中，Gj,可能在生成长度为n的z时查询过B。

假设N是对于存在K中长度为N的字符串的整数n中最接近的。当log(Nck) ≤ n ≤ 2N/ck时，情况较为复杂；否则，f可以通过对B  = QBF @ K 的查询构造一个证人，证明x ∈ L(Nj)。因此，假设R = 2N/ck。破解者f首先使用B 确定是否存在一个硬币翻转序列s，如果Gj,使用B ，则在输入1"时输出x。如果存在这样的s，则f可以使用PSPACE构造一个，并进一步构造一个证人；这个构造可能涉及发现随机字符串r ∈ K \ K 。如果不存在这样的s，则f无法构造一个证人。然而，我们证明，唯一没有这样的s的时间（因此f唯一失败的时间）是Gj,实际上查询了B关于r是否属于K的成员。我们通过一个计数论证来完成证明，表明如果这种情况以任何常数概率a发生，则r不能具有最大的Kolmogorov复杂度。


\section{讨论、相关工作和开放问题 }


设S是一个NP集合，N是一台接受S的特定机器。回顾一下，w”是N在输入2上的接受路径集合。如果存在一个随机化多项式时间程序，在输入1*时生成对(5, w)，其中111=n，使得赋予x的概率与IwFI成比例，则我们说S是规范可生成的。第1节中给出的Hamiltonian图、3SAT公式和子集和实例的直接生成方案都是规范的，相对于这些集合的通常类型的证据。我们称这些生成器为规范的主要原因是，从某种意义上说，所有NP集合的生成器都是规范的。如果G;,3是集合S的生成方案，那么导致M,输出(z,w)的硬币翻转序列是证据，证明z属于S，赋予特定z的概率显然与导致其输出的硬币翻转序列的数量比例。Hamiltonian图的直接规范生成方案具有这种通用形式：生成2u均匀地，然后从所有实例集合中均匀地选择z，使得2u是证据，证明z属于S。实际上，许多NP集合（例如，SAT、具有完美匹配的图、具有大小为IV(G)1/2的团的图）都有这种形式的规范生成方案，相对于这些集合的通常类型的证据。这自然引出了一个问题，即是否每个NP集合都具有这种形式的规范生成方案，相对于每种类型的证据。对这个问题的回答是否定的，除非NP集合的构造问题总能以多项式时间解决。（构造问题是：给定一个实例I，如果z是一个yes-instance，则找到一个，如果z是一个no-instance，则说没有证据。）
进一步研究的有趣领域是可生成（即规范）分布与Levin等人研究过的“平均困难”分布之间的关系。Levin的随机NP（表示为RNP）是一类对(D, p)，其中D是NP中的任何决策问题，p是任何在(0,1)上的概率函数（解释为D的实例）的累积分布函数p*(z) = Zz<=p(z)是多项式时间可计算的。在1221年，Venkatesan和Levin将定义扩展到NP中的构造问题；他们允许的分布仍然是那些多项式时间可计算的p*。Venkatesan和Levin展示了一个R-hard的构造问题，即如果存在一个算法可以在期望的多项式时间内解决它，那么所有RNP-构造问题都可以在期望的多项式时间内解决。他们考虑的实例分布很容易生成；然而，它赋予no-instances正概率。308
这暗示了一些自然的问题。是否存在一个R-hard分布（一个构造问题的实例的分布），它只对是实例赋予正概率？如果坚持在生成实例的同时生成证据，这个分布能否高效生成？要求一个分布是高效可生成的，并且它的p*是高效可计算的，这两个要求是否互斥？例如，我们为哈密顿的典型生成方案产生了一个分布，这个分布可能没有多项式时间可计算的p*：如果它有，那么计算图中的哈密顿周期的#P-Complete问题就可以在多项式时间内解决。最后，我们想提到，解决实例的生成也被Fbrdin、Tovey和ilcher [18]考虑过；他们的目标是构建启发式算法的测试实例。